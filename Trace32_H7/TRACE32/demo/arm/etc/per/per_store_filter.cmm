; --------------------------------------------------------------------------------
; @Title: Filter PER.STOre file
; @Description:
;   Allows to filter/sort a file generated by `PER.STOre` e.g. for A-/R-profile
;   processors ARMv8 onwards.
;   Example:
;     PER.STOre ./store.stage1.cmm ~~/perarmv87a.per
;     DO ~~/demo/arm/etc/per/per_store_filter \
;       "./store.stage1.cmm" "./store.stage2.cmm" \
;       "*?_EL3,*?_EL2","*?_EL12","*?_EL02,*?_EL1,*>_EL0"
; @Keywords: PER STOre
; @Author: AME
; @Copyright: (C) 1989-2023 Lauterbach GmbH, licensed for use with TRACE32(R) only
; --------------------------------------------------------------------------------
; $Id: per_store_filter.cm 9162 2023-06-12 09:10:23Z amerkle $

PARAMETERS &sInFile &sOutFile &sFilter

GOSUB perStoreFilter "&sInFile" "&sOutFile" "&sFilter"

ENDDO

perStoreFilter: ;(sInFile, sOutFile)
(
  PRIVATE &sInFile &sOutFile &sFilter &nHandle &sHandle &sLine
  PARAMETERS &sInFile &sOutFile &sFilter
  
  ; detect available filehandle
  &nHandle=0.
  RePeaT
  (
    &nHandle=&nHandle+1.
  )
  WHILE FILE.OPEN(&nHandle)
  SPRINTF &sHandle "#%u" &nHandle
  
  ; count lines, detect maximum length
  PRIVATE &nLineCount &nLineLength
  &nLineCount=0.
  &nLineLength=0.
  OPEN &sHandle "&sInFile" /Read
  READ &sHandle %LINE &sLine
  WHILE !FILE.EOF(&nHandle)
  (
    PRIVATE &nLength
    &nLength=STRing.LENgth("&sLine")
    IF (&nLineLength<&nLength)
      &nLineLength=&nLength
    &nLineCount=&nLineCount+1.

    READ &sHandle %LINE &sLine
  )
  CLOSE &sHandle

  IF (&nLineCount==0)
    RETURN

  ; read all lines into an hll-array
  PRIVATE &nLineCount2 &nLineLength2
  &nLineCount2=&nLineCount+1.
  &nLineLength2=&nLineLength+1.
  Var.NEWLOCAL char[&nLineCount2][&nLineLength2] \ppLines
  Var.NEWLOCAL int \i
  OPEN &sHandle "&sInFile" /Read
  READ &sHandle %LINE &sLine
  Var.Assign \i = 0
  RePeaT &nLineCount
  (
    Var.Assign \ppLines[\i++] = "&sLine"

    READ &sHandle %LINE &sLine
  )
  CLOSE &sHandle

  ; apply semicolon separated filters to register names
  PRIVATE &j &sFilterToken
  &j=0.
  IF ("&sFilter"=="")
    &sFilter="*"
  RePeaT
  (
    &sFilterToken=STRing.TOKEN("&sFilter",";",&j)
    IF ("&sFilterToken"!="")
      GOSUB perStoreFilter_process "&sOutFile" "\ppLines" "&nLineCount" "&sFilterToken"

    &j=&j+1.
  )
  WHILE ("&sFilterToken"!="")
  RETURN
)

; --------------------------------------------------------------------------------

perStoreFilter_process: ;(sOutFile, sHllLines, nLineCount, sCompareExpr)
(
  PRIVATE &sOutFile &sHllLines &nLineCount &sFilter
  PARAMETERS &sOutFile &sHllLines &nLineCount &sFilter
  PRIVATE &sLine &sLineOut &bHeading &bRoRegister &bOnErrorInheritPending
  Var.NEWLOCAL int \i
  Var.Assign \i = 0
  &bHeading=FALSE()
  &bRoRegister=FALSE()
  &bOnErrorInheritPending=FALSE()
  &sLineOut=""
  Var.WHILE \i<&nLineCount
  (
    &sLine=Var.STRing(&sHllLines[\i])
    IF ("&sLine"=="")
    (
      ; empty line - nothing todo
    )
    ELSE IF STRing.ComPare("&sLine","// *")
    (
      ; a heading / tree is signaled via a comment line without an indent
      ; e.g. `// Virtualization Extensions`
      &sLineOut="&sLine"
      &bHeading=TRUE()
    )
    ELSE
    (
      PRIVATE &sLineTrim &sComment &sRegisterName &sReason
      ; example lines:
      ; `PER.Set.simple SPR:0x34111 %Quad 0x8  // MDCR_EL2`
      ; `// PER.Set.simple SPR:0x30012 %Quad 0x17011099  // ID_DFR0_EL1; reason=read-only`
      ; `// PER.Set.simple SPR:0x34316 %Quad 0x0  // HAFGRTR_EL2; reason=access_error`
      &sLineTrim=STRing.TRIM("&sLine")
      &sComment=STRing.TRIM(STRing.TOKEN("&sLineTrim","//",-1.,"DELIMITER=STRING"))
      &sRegisterName=STRing.TRIM(STRing.TOKEN("&sComment","; ",0.))
      &sReason=STRing.SCANAndExtract("&sComment","reason=","")
      IF STRing.ComPare("&sRegisterName","&(sFilter)")
      (
        &bRoRegister=("&sReason"=="read-only")
        IF (&bRoRegister)
        (
          ; remove comment markers from `reason=read-only` registers
          ; - try to restore them but ignore errors
          &sLineOut="  "+STRing.TRIM(STRing.CUT("&sLineTrim",2.))
        )
        ELSE
        (
          &sLineOut="  &sLineTrim"
        )
      )
    )
    IF ("&sLineOut"!="")
    (
      IF ((&bRoRegister)&&(!&bOnErrorInheritPending))
        APPEND "&sOutFile" "  ON ERROR CONTinue"
      ELSE IF ((&bOnErrorInheritPending)&&(!&bRoRegister))
        APPEND "&sOutFile" "  ON ERROR inherit"
      APPEND "&sOutFile" "&sLineOut"
      &bOnErrorInheritPending=&bRoRegister
 
      IF (!&bHeading)
        Var.Assign &sHllLines[\i] = ""
      &bHeading=FALSE()
      &bRoRegister=FALSE()
      &sLineOut=""
    )
    Var.Assign \i++
  )
  
  IF (&bOnErrorInheritPending)
    APPEND "&sOutFile" "  ON ERROR inherit"

  RETURN
)
